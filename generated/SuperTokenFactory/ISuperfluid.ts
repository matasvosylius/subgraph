// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class AgreementClassRegistered extends ethereum.Event {
  get params(): AgreementClassRegistered__Params {
    return new AgreementClassRegistered__Params(this);
  }
}

export class AgreementClassRegistered__Params {
  _event: AgreementClassRegistered;

  constructor(event: AgreementClassRegistered) {
    this._event = event;
  }

  get agreementType(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get code(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class AgreementClassUpdated extends ethereum.Event {
  get params(): AgreementClassUpdated__Params {
    return new AgreementClassUpdated__Params(this);
  }
}

export class AgreementClassUpdated__Params {
  _event: AgreementClassUpdated;

  constructor(event: AgreementClassUpdated) {
    this._event = event;
  }

  get agreementType(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get code(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class AppRegistered extends ethereum.Event {
  get params(): AppRegistered__Params {
    return new AppRegistered__Params(this);
  }
}

export class AppRegistered__Params {
  _event: AppRegistered;

  constructor(event: AppRegistered) {
    this._event = event;
  }

  get app(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class GovernanceReplaced extends ethereum.Event {
  get params(): GovernanceReplaced__Params {
    return new GovernanceReplaced__Params(this);
  }
}

export class GovernanceReplaced__Params {
  _event: GovernanceReplaced;

  constructor(event: GovernanceReplaced) {
    this._event = event;
  }

  get oldGov(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newGov(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class Jail extends ethereum.Event {
  get params(): Jail__Params {
    return new Jail__Params(this);
  }
}

export class Jail__Params {
  _event: Jail;

  constructor(event: Jail) {
    this._event = event;
  }

  get app(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get reason(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class SuperTokenFactoryUpdated extends ethereum.Event {
  get params(): SuperTokenFactoryUpdated__Params {
    return new SuperTokenFactoryUpdated__Params(this);
  }
}

export class SuperTokenFactoryUpdated__Params {
  _event: SuperTokenFactoryUpdated;

  constructor(event: SuperTokenFactoryUpdated) {
    this._event = event;
  }

  get newFactory(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class SuperTokenLogicUpdated extends ethereum.Event {
  get params(): SuperTokenLogicUpdated__Params {
    return new SuperTokenLogicUpdated__Params(this);
  }
}

export class SuperTokenLogicUpdated__Params {
  _event: SuperTokenLogicUpdated;

  constructor(event: SuperTokenLogicUpdated) {
    this._event = event;
  }

  get token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get code(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class ISuperfluid__getAppManifestResult {
  value0: boolean;
  value1: boolean;
  value2: BigInt;

  constructor(value0: boolean, value1: boolean, value2: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromBoolean(this.value0));
    map.set("value1", ethereum.Value.fromBoolean(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    return map;
  }
}

export class ISuperfluid__callAgreementWithContextResult {
  value0: Bytes;
  value1: Bytes;

  constructor(value0: Bytes, value1: Bytes) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromBytes(this.value0));
    map.set("value1", ethereum.Value.fromBytes(this.value1));
    return map;
  }
}

export class ISuperfluid__decodeCtxResultContextStruct extends ethereum.Tuple {
  get appLevel(): i32 {
    return this[0].toI32();
  }

  get callType(): i32 {
    return this[1].toI32();
  }

  get timestamp(): BigInt {
    return this[2].toBigInt();
  }

  get msgSender(): Address {
    return this[3].toAddress();
  }

  get agreementSelector(): Bytes {
    return this[4].toBytes();
  }

  get userData(): Bytes {
    return this[5].toBytes();
  }

  get appAllowanceGranted(): BigInt {
    return this[6].toBigInt();
  }

  get appAllowanceWanted(): BigInt {
    return this[7].toBigInt();
  }

  get appAllowanceUsed(): BigInt {
    return this[8].toBigInt();
  }

  get appAddress(): Address {
    return this[9].toAddress();
  }

  get appAllowanceToken(): Address {
    return this[10].toAddress();
  }
}

export class ISuperfluid extends ethereum.SmartContract {
  static bind(address: Address): ISuperfluid {
    return new ISuperfluid("ISuperfluid", address);
  }

  getGovernance(): Address {
    let result = super.call("getGovernance", "getGovernance():(address)", []);

    return result[0].toAddress();
  }

  try_getGovernance(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getGovernance",
      "getGovernance():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  isAgreementTypeListed(agreementType: Bytes): boolean {
    let result = super.call(
      "isAgreementTypeListed",
      "isAgreementTypeListed(bytes32):(bool)",
      [ethereum.Value.fromFixedBytes(agreementType)]
    );

    return result[0].toBoolean();
  }

  try_isAgreementTypeListed(
    agreementType: Bytes
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isAgreementTypeListed",
      "isAgreementTypeListed(bytes32):(bool)",
      [ethereum.Value.fromFixedBytes(agreementType)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isAgreementClassListed(agreementClass: Address): boolean {
    let result = super.call(
      "isAgreementClassListed",
      "isAgreementClassListed(address):(bool)",
      [ethereum.Value.fromAddress(agreementClass)]
    );

    return result[0].toBoolean();
  }

  try_isAgreementClassListed(
    agreementClass: Address
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isAgreementClassListed",
      "isAgreementClassListed(address):(bool)",
      [ethereum.Value.fromAddress(agreementClass)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  getAgreementClass(agreementType: Bytes): Address {
    let result = super.call(
      "getAgreementClass",
      "getAgreementClass(bytes32):(address)",
      [ethereum.Value.fromFixedBytes(agreementType)]
    );

    return result[0].toAddress();
  }

  try_getAgreementClass(agreementType: Bytes): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getAgreementClass",
      "getAgreementClass(bytes32):(address)",
      [ethereum.Value.fromFixedBytes(agreementType)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  mapAgreementClasses(bitmap: BigInt): Array<Address> {
    let result = super.call(
      "mapAgreementClasses",
      "mapAgreementClasses(uint256):(address[])",
      [ethereum.Value.fromUnsignedBigInt(bitmap)]
    );

    return result[0].toAddressArray();
  }

  try_mapAgreementClasses(bitmap: BigInt): ethereum.CallResult<Array<Address>> {
    let result = super.tryCall(
      "mapAgreementClasses",
      "mapAgreementClasses(uint256):(address[])",
      [ethereum.Value.fromUnsignedBigInt(bitmap)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddressArray());
  }

  addToAgreementClassesBitmap(bitmap: BigInt, agreementType: Bytes): BigInt {
    let result = super.call(
      "addToAgreementClassesBitmap",
      "addToAgreementClassesBitmap(uint256,bytes32):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(bitmap),
        ethereum.Value.fromFixedBytes(agreementType)
      ]
    );

    return result[0].toBigInt();
  }

  try_addToAgreementClassesBitmap(
    bitmap: BigInt,
    agreementType: Bytes
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "addToAgreementClassesBitmap",
      "addToAgreementClassesBitmap(uint256,bytes32):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(bitmap),
        ethereum.Value.fromFixedBytes(agreementType)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  removeFromAgreementClassesBitmap(
    bitmap: BigInt,
    agreementType: Bytes
  ): BigInt {
    let result = super.call(
      "removeFromAgreementClassesBitmap",
      "removeFromAgreementClassesBitmap(uint256,bytes32):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(bitmap),
        ethereum.Value.fromFixedBytes(agreementType)
      ]
    );

    return result[0].toBigInt();
  }

  try_removeFromAgreementClassesBitmap(
    bitmap: BigInt,
    agreementType: Bytes
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "removeFromAgreementClassesBitmap",
      "removeFromAgreementClassesBitmap(uint256,bytes32):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(bitmap),
        ethereum.Value.fromFixedBytes(agreementType)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getSuperTokenFactory(): Address {
    let result = super.call(
      "getSuperTokenFactory",
      "getSuperTokenFactory():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_getSuperTokenFactory(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getSuperTokenFactory",
      "getSuperTokenFactory():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getSuperTokenFactoryLogic(): Address {
    let result = super.call(
      "getSuperTokenFactoryLogic",
      "getSuperTokenFactoryLogic():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_getSuperTokenFactoryLogic(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getSuperTokenFactoryLogic",
      "getSuperTokenFactoryLogic():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  isApp(app: Address): boolean {
    let result = super.call("isApp", "isApp(address):(bool)", [
      ethereum.Value.fromAddress(app)
    ]);

    return result[0].toBoolean();
  }

  try_isApp(app: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isApp", "isApp(address):(bool)", [
      ethereum.Value.fromAddress(app)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  getAppLevel(app: Address): i32 {
    let result = super.call("getAppLevel", "getAppLevel(address):(uint8)", [
      ethereum.Value.fromAddress(app)
    ]);

    return result[0].toI32();
  }

  try_getAppLevel(app: Address): ethereum.CallResult<i32> {
    let result = super.tryCall("getAppLevel", "getAppLevel(address):(uint8)", [
      ethereum.Value.fromAddress(app)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  getAppManifest(app: Address): ISuperfluid__getAppManifestResult {
    let result = super.call(
      "getAppManifest",
      "getAppManifest(address):(bool,bool,uint256)",
      [ethereum.Value.fromAddress(app)]
    );

    return new ISuperfluid__getAppManifestResult(
      result[0].toBoolean(),
      result[1].toBoolean(),
      result[2].toBigInt()
    );
  }

  try_getAppManifest(
    app: Address
  ): ethereum.CallResult<ISuperfluid__getAppManifestResult> {
    let result = super.tryCall(
      "getAppManifest",
      "getAppManifest(address):(bool,bool,uint256)",
      [ethereum.Value.fromAddress(app)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new ISuperfluid__getAppManifestResult(
        value[0].toBoolean(),
        value[1].toBoolean(),
        value[2].toBigInt()
      )
    );
  }

  isAppJailed(app: Address): boolean {
    let result = super.call("isAppJailed", "isAppJailed(address):(bool)", [
      ethereum.Value.fromAddress(app)
    ]);

    return result[0].toBoolean();
  }

  try_isAppJailed(app: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isAppJailed", "isAppJailed(address):(bool)", [
      ethereum.Value.fromAddress(app)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isCompositeAppAllowed(app: Address, targetApp: Address): boolean {
    let result = super.call(
      "isCompositeAppAllowed",
      "isCompositeAppAllowed(address,address):(bool)",
      [ethereum.Value.fromAddress(app), ethereum.Value.fromAddress(targetApp)]
    );

    return result[0].toBoolean();
  }

  try_isCompositeAppAllowed(
    app: Address,
    targetApp: Address
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isCompositeAppAllowed",
      "isCompositeAppAllowed(address,address):(bool)",
      [ethereum.Value.fromAddress(app), ethereum.Value.fromAddress(targetApp)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  callAppBeforeCallback(
    app: Address,
    callData: Bytes,
    isTermination: boolean,
    ctx: Bytes
  ): Bytes {
    let result = super.call(
      "callAppBeforeCallback",
      "callAppBeforeCallback(address,bytes,bool,bytes):(bytes)",
      [
        ethereum.Value.fromAddress(app),
        ethereum.Value.fromBytes(callData),
        ethereum.Value.fromBoolean(isTermination),
        ethereum.Value.fromBytes(ctx)
      ]
    );

    return result[0].toBytes();
  }

  try_callAppBeforeCallback(
    app: Address,
    callData: Bytes,
    isTermination: boolean,
    ctx: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "callAppBeforeCallback",
      "callAppBeforeCallback(address,bytes,bool,bytes):(bytes)",
      [
        ethereum.Value.fromAddress(app),
        ethereum.Value.fromBytes(callData),
        ethereum.Value.fromBoolean(isTermination),
        ethereum.Value.fromBytes(ctx)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  callAppAfterCallback(
    app: Address,
    callData: Bytes,
    isTermination: boolean,
    ctx: Bytes
  ): Bytes {
    let result = super.call(
      "callAppAfterCallback",
      "callAppAfterCallback(address,bytes,bool,bytes):(bytes)",
      [
        ethereum.Value.fromAddress(app),
        ethereum.Value.fromBytes(callData),
        ethereum.Value.fromBoolean(isTermination),
        ethereum.Value.fromBytes(ctx)
      ]
    );

    return result[0].toBytes();
  }

  try_callAppAfterCallback(
    app: Address,
    callData: Bytes,
    isTermination: boolean,
    ctx: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "callAppAfterCallback",
      "callAppAfterCallback(address,bytes,bool,bytes):(bytes)",
      [
        ethereum.Value.fromAddress(app),
        ethereum.Value.fromBytes(callData),
        ethereum.Value.fromBoolean(isTermination),
        ethereum.Value.fromBytes(ctx)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  appCallbackPush(
    ctx: Bytes,
    app: Address,
    appAllowanceGranted: BigInt,
    appAllowanceUsed: BigInt,
    appAllowanceToken: Address
  ): Bytes {
    let result = super.call(
      "appCallbackPush",
      "appCallbackPush(bytes,address,uint256,int256,address):(bytes)",
      [
        ethereum.Value.fromBytes(ctx),
        ethereum.Value.fromAddress(app),
        ethereum.Value.fromUnsignedBigInt(appAllowanceGranted),
        ethereum.Value.fromSignedBigInt(appAllowanceUsed),
        ethereum.Value.fromAddress(appAllowanceToken)
      ]
    );

    return result[0].toBytes();
  }

  try_appCallbackPush(
    ctx: Bytes,
    app: Address,
    appAllowanceGranted: BigInt,
    appAllowanceUsed: BigInt,
    appAllowanceToken: Address
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "appCallbackPush",
      "appCallbackPush(bytes,address,uint256,int256,address):(bytes)",
      [
        ethereum.Value.fromBytes(ctx),
        ethereum.Value.fromAddress(app),
        ethereum.Value.fromUnsignedBigInt(appAllowanceGranted),
        ethereum.Value.fromSignedBigInt(appAllowanceUsed),
        ethereum.Value.fromAddress(appAllowanceToken)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  appCallbackPop(ctx: Bytes, appAllowanceUsedDelta: BigInt): Bytes {
    let result = super.call(
      "appCallbackPop",
      "appCallbackPop(bytes,int256):(bytes)",
      [
        ethereum.Value.fromBytes(ctx),
        ethereum.Value.fromSignedBigInt(appAllowanceUsedDelta)
      ]
    );

    return result[0].toBytes();
  }

  try_appCallbackPop(
    ctx: Bytes,
    appAllowanceUsedDelta: BigInt
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "appCallbackPop",
      "appCallbackPop(bytes,int256):(bytes)",
      [
        ethereum.Value.fromBytes(ctx),
        ethereum.Value.fromSignedBigInt(appAllowanceUsedDelta)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  ctxUseAllowance(
    ctx: Bytes,
    appAllowanceWantedMore: BigInt,
    appAllowanceUsedDelta: BigInt
  ): Bytes {
    let result = super.call(
      "ctxUseAllowance",
      "ctxUseAllowance(bytes,uint256,int256):(bytes)",
      [
        ethereum.Value.fromBytes(ctx),
        ethereum.Value.fromUnsignedBigInt(appAllowanceWantedMore),
        ethereum.Value.fromSignedBigInt(appAllowanceUsedDelta)
      ]
    );

    return result[0].toBytes();
  }

  try_ctxUseAllowance(
    ctx: Bytes,
    appAllowanceWantedMore: BigInt,
    appAllowanceUsedDelta: BigInt
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "ctxUseAllowance",
      "ctxUseAllowance(bytes,uint256,int256):(bytes)",
      [
        ethereum.Value.fromBytes(ctx),
        ethereum.Value.fromUnsignedBigInt(appAllowanceWantedMore),
        ethereum.Value.fromSignedBigInt(appAllowanceUsedDelta)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  jailApp(ctx: Bytes, app: Address, reason: BigInt): Bytes {
    let result = super.call(
      "jailApp",
      "jailApp(bytes,address,uint256):(bytes)",
      [
        ethereum.Value.fromBytes(ctx),
        ethereum.Value.fromAddress(app),
        ethereum.Value.fromUnsignedBigInt(reason)
      ]
    );

    return result[0].toBytes();
  }

  try_jailApp(
    ctx: Bytes,
    app: Address,
    reason: BigInt
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "jailApp",
      "jailApp(bytes,address,uint256):(bytes)",
      [
        ethereum.Value.fromBytes(ctx),
        ethereum.Value.fromAddress(app),
        ethereum.Value.fromUnsignedBigInt(reason)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  callAgreement(
    agreementClass: Address,
    callData: Bytes,
    userData: Bytes
  ): Bytes {
    let result = super.call(
      "callAgreement",
      "callAgreement(address,bytes,bytes):(bytes)",
      [
        ethereum.Value.fromAddress(agreementClass),
        ethereum.Value.fromBytes(callData),
        ethereum.Value.fromBytes(userData)
      ]
    );

    return result[0].toBytes();
  }

  try_callAgreement(
    agreementClass: Address,
    callData: Bytes,
    userData: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "callAgreement",
      "callAgreement(address,bytes,bytes):(bytes)",
      [
        ethereum.Value.fromAddress(agreementClass),
        ethereum.Value.fromBytes(callData),
        ethereum.Value.fromBytes(userData)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  callAppAction(app: Address, callData: Bytes): Bytes {
    let result = super.call(
      "callAppAction",
      "callAppAction(address,bytes):(bytes)",
      [ethereum.Value.fromAddress(app), ethereum.Value.fromBytes(callData)]
    );

    return result[0].toBytes();
  }

  try_callAppAction(app: Address, callData: Bytes): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "callAppAction",
      "callAppAction(address,bytes):(bytes)",
      [ethereum.Value.fromAddress(app), ethereum.Value.fromBytes(callData)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  callAgreementWithContext(
    agreementClass: Address,
    callData: Bytes,
    userData: Bytes,
    ctx: Bytes
  ): ISuperfluid__callAgreementWithContextResult {
    let result = super.call(
      "callAgreementWithContext",
      "callAgreementWithContext(address,bytes,bytes,bytes):(bytes,bytes)",
      [
        ethereum.Value.fromAddress(agreementClass),
        ethereum.Value.fromBytes(callData),
        ethereum.Value.fromBytes(userData),
        ethereum.Value.fromBytes(ctx)
      ]
    );

    return new ISuperfluid__callAgreementWithContextResult(
      result[0].toBytes(),
      result[1].toBytes()
    );
  }

  try_callAgreementWithContext(
    agreementClass: Address,
    callData: Bytes,
    userData: Bytes,
    ctx: Bytes
  ): ethereum.CallResult<ISuperfluid__callAgreementWithContextResult> {
    let result = super.tryCall(
      "callAgreementWithContext",
      "callAgreementWithContext(address,bytes,bytes,bytes):(bytes,bytes)",
      [
        ethereum.Value.fromAddress(agreementClass),
        ethereum.Value.fromBytes(callData),
        ethereum.Value.fromBytes(userData),
        ethereum.Value.fromBytes(ctx)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new ISuperfluid__callAgreementWithContextResult(
        value[0].toBytes(),
        value[1].toBytes()
      )
    );
  }

  callAppActionWithContext(app: Address, callData: Bytes, ctx: Bytes): Bytes {
    let result = super.call(
      "callAppActionWithContext",
      "callAppActionWithContext(address,bytes,bytes):(bytes)",
      [
        ethereum.Value.fromAddress(app),
        ethereum.Value.fromBytes(callData),
        ethereum.Value.fromBytes(ctx)
      ]
    );

    return result[0].toBytes();
  }

  try_callAppActionWithContext(
    app: Address,
    callData: Bytes,
    ctx: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "callAppActionWithContext",
      "callAppActionWithContext(address,bytes,bytes):(bytes)",
      [
        ethereum.Value.fromAddress(app),
        ethereum.Value.fromBytes(callData),
        ethereum.Value.fromBytes(ctx)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  decodeCtx(ctx: Bytes): ISuperfluid__decodeCtxResultContextStruct {
    let result = super.call(
      "decodeCtx",
      "decodeCtx(bytes):((uint8,uint8,uint256,address,bytes4,bytes,uint256,uint256,int256,address,address))",
      [ethereum.Value.fromBytes(ctx)]
    );

    return result[0].toTuple() as ISuperfluid__decodeCtxResultContextStruct;
  }

  try_decodeCtx(
    ctx: Bytes
  ): ethereum.CallResult<ISuperfluid__decodeCtxResultContextStruct> {
    let result = super.tryCall(
      "decodeCtx",
      "decodeCtx(bytes):((uint8,uint8,uint256,address,bytes4,bytes,uint256,uint256,int256,address,address))",
      [ethereum.Value.fromBytes(ctx)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTuple() as ISuperfluid__decodeCtxResultContextStruct
    );
  }

  isCtxValid(ctx: Bytes): boolean {
    let result = super.call("isCtxValid", "isCtxValid(bytes):(bool)", [
      ethereum.Value.fromBytes(ctx)
    ]);

    return result[0].toBoolean();
  }

  try_isCtxValid(ctx: Bytes): ethereum.CallResult<boolean> {
    let result = super.tryCall("isCtxValid", "isCtxValid(bytes):(bool)", [
      ethereum.Value.fromBytes(ctx)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }
}

export class ReplaceGovernanceCall extends ethereum.Call {
  get inputs(): ReplaceGovernanceCall__Inputs {
    return new ReplaceGovernanceCall__Inputs(this);
  }

  get outputs(): ReplaceGovernanceCall__Outputs {
    return new ReplaceGovernanceCall__Outputs(this);
  }
}

export class ReplaceGovernanceCall__Inputs {
  _call: ReplaceGovernanceCall;

  constructor(call: ReplaceGovernanceCall) {
    this._call = call;
  }

  get newGov(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class ReplaceGovernanceCall__Outputs {
  _call: ReplaceGovernanceCall;

  constructor(call: ReplaceGovernanceCall) {
    this._call = call;
  }
}

export class RegisterAgreementClassCall extends ethereum.Call {
  get inputs(): RegisterAgreementClassCall__Inputs {
    return new RegisterAgreementClassCall__Inputs(this);
  }

  get outputs(): RegisterAgreementClassCall__Outputs {
    return new RegisterAgreementClassCall__Outputs(this);
  }
}

export class RegisterAgreementClassCall__Inputs {
  _call: RegisterAgreementClassCall;

  constructor(call: RegisterAgreementClassCall) {
    this._call = call;
  }

  get agreementClassLogic(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class RegisterAgreementClassCall__Outputs {
  _call: RegisterAgreementClassCall;

  constructor(call: RegisterAgreementClassCall) {
    this._call = call;
  }
}

export class UpdateAgreementClassCall extends ethereum.Call {
  get inputs(): UpdateAgreementClassCall__Inputs {
    return new UpdateAgreementClassCall__Inputs(this);
  }

  get outputs(): UpdateAgreementClassCall__Outputs {
    return new UpdateAgreementClassCall__Outputs(this);
  }
}

export class UpdateAgreementClassCall__Inputs {
  _call: UpdateAgreementClassCall;

  constructor(call: UpdateAgreementClassCall) {
    this._call = call;
  }

  get agreementClassLogic(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class UpdateAgreementClassCall__Outputs {
  _call: UpdateAgreementClassCall;

  constructor(call: UpdateAgreementClassCall) {
    this._call = call;
  }
}

export class UpdateSuperTokenFactoryCall extends ethereum.Call {
  get inputs(): UpdateSuperTokenFactoryCall__Inputs {
    return new UpdateSuperTokenFactoryCall__Inputs(this);
  }

  get outputs(): UpdateSuperTokenFactoryCall__Outputs {
    return new UpdateSuperTokenFactoryCall__Outputs(this);
  }
}

export class UpdateSuperTokenFactoryCall__Inputs {
  _call: UpdateSuperTokenFactoryCall;

  constructor(call: UpdateSuperTokenFactoryCall) {
    this._call = call;
  }

  get newFactory(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class UpdateSuperTokenFactoryCall__Outputs {
  _call: UpdateSuperTokenFactoryCall;

  constructor(call: UpdateSuperTokenFactoryCall) {
    this._call = call;
  }
}

export class UpdateSuperTokenLogicCall extends ethereum.Call {
  get inputs(): UpdateSuperTokenLogicCall__Inputs {
    return new UpdateSuperTokenLogicCall__Inputs(this);
  }

  get outputs(): UpdateSuperTokenLogicCall__Outputs {
    return new UpdateSuperTokenLogicCall__Outputs(this);
  }
}

export class UpdateSuperTokenLogicCall__Inputs {
  _call: UpdateSuperTokenLogicCall;

  constructor(call: UpdateSuperTokenLogicCall) {
    this._call = call;
  }

  get token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class UpdateSuperTokenLogicCall__Outputs {
  _call: UpdateSuperTokenLogicCall;

  constructor(call: UpdateSuperTokenLogicCall) {
    this._call = call;
  }
}

export class RegisterAppCall extends ethereum.Call {
  get inputs(): RegisterAppCall__Inputs {
    return new RegisterAppCall__Inputs(this);
  }

  get outputs(): RegisterAppCall__Outputs {
    return new RegisterAppCall__Outputs(this);
  }
}

export class RegisterAppCall__Inputs {
  _call: RegisterAppCall;

  constructor(call: RegisterAppCall) {
    this._call = call;
  }

  get configWord(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class RegisterAppCall__Outputs {
  _call: RegisterAppCall;

  constructor(call: RegisterAppCall) {
    this._call = call;
  }
}

export class RegisterAppWithKeyCall extends ethereum.Call {
  get inputs(): RegisterAppWithKeyCall__Inputs {
    return new RegisterAppWithKeyCall__Inputs(this);
  }

  get outputs(): RegisterAppWithKeyCall__Outputs {
    return new RegisterAppWithKeyCall__Outputs(this);
  }
}

export class RegisterAppWithKeyCall__Inputs {
  _call: RegisterAppWithKeyCall;

  constructor(call: RegisterAppWithKeyCall) {
    this._call = call;
  }

  get configWord(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get registrationKey(): string {
    return this._call.inputValues[1].value.toString();
  }
}

export class RegisterAppWithKeyCall__Outputs {
  _call: RegisterAppWithKeyCall;

  constructor(call: RegisterAppWithKeyCall) {
    this._call = call;
  }
}

export class AllowCompositeAppCall extends ethereum.Call {
  get inputs(): AllowCompositeAppCall__Inputs {
    return new AllowCompositeAppCall__Inputs(this);
  }

  get outputs(): AllowCompositeAppCall__Outputs {
    return new AllowCompositeAppCall__Outputs(this);
  }
}

export class AllowCompositeAppCall__Inputs {
  _call: AllowCompositeAppCall;

  constructor(call: AllowCompositeAppCall) {
    this._call = call;
  }

  get targetApp(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class AllowCompositeAppCall__Outputs {
  _call: AllowCompositeAppCall;

  constructor(call: AllowCompositeAppCall) {
    this._call = call;
  }
}

export class CallAppBeforeCallbackCall extends ethereum.Call {
  get inputs(): CallAppBeforeCallbackCall__Inputs {
    return new CallAppBeforeCallbackCall__Inputs(this);
  }

  get outputs(): CallAppBeforeCallbackCall__Outputs {
    return new CallAppBeforeCallbackCall__Outputs(this);
  }
}

export class CallAppBeforeCallbackCall__Inputs {
  _call: CallAppBeforeCallbackCall;

  constructor(call: CallAppBeforeCallbackCall) {
    this._call = call;
  }

  get app(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get callData(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get isTermination(): boolean {
    return this._call.inputValues[2].value.toBoolean();
  }

  get ctx(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }
}

export class CallAppBeforeCallbackCall__Outputs {
  _call: CallAppBeforeCallbackCall;

  constructor(call: CallAppBeforeCallbackCall) {
    this._call = call;
  }

  get cbdata(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}

export class CallAppAfterCallbackCall extends ethereum.Call {
  get inputs(): CallAppAfterCallbackCall__Inputs {
    return new CallAppAfterCallbackCall__Inputs(this);
  }

  get outputs(): CallAppAfterCallbackCall__Outputs {
    return new CallAppAfterCallbackCall__Outputs(this);
  }
}

export class CallAppAfterCallbackCall__Inputs {
  _call: CallAppAfterCallbackCall;

  constructor(call: CallAppAfterCallbackCall) {
    this._call = call;
  }

  get app(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get callData(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get isTermination(): boolean {
    return this._call.inputValues[2].value.toBoolean();
  }

  get ctx(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }
}

export class CallAppAfterCallbackCall__Outputs {
  _call: CallAppAfterCallbackCall;

  constructor(call: CallAppAfterCallbackCall) {
    this._call = call;
  }

  get appCtx(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}

export class AppCallbackPushCall extends ethereum.Call {
  get inputs(): AppCallbackPushCall__Inputs {
    return new AppCallbackPushCall__Inputs(this);
  }

  get outputs(): AppCallbackPushCall__Outputs {
    return new AppCallbackPushCall__Outputs(this);
  }
}

export class AppCallbackPushCall__Inputs {
  _call: AppCallbackPushCall;

  constructor(call: AppCallbackPushCall) {
    this._call = call;
  }

  get ctx(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get app(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get appAllowanceGranted(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get appAllowanceUsed(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get appAllowanceToken(): Address {
    return this._call.inputValues[4].value.toAddress();
  }
}

export class AppCallbackPushCall__Outputs {
  _call: AppCallbackPushCall;

  constructor(call: AppCallbackPushCall) {
    this._call = call;
  }

  get appCtx(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}

export class AppCallbackPopCall extends ethereum.Call {
  get inputs(): AppCallbackPopCall__Inputs {
    return new AppCallbackPopCall__Inputs(this);
  }

  get outputs(): AppCallbackPopCall__Outputs {
    return new AppCallbackPopCall__Outputs(this);
  }
}

export class AppCallbackPopCall__Inputs {
  _call: AppCallbackPopCall;

  constructor(call: AppCallbackPopCall) {
    this._call = call;
  }

  get ctx(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get appAllowanceUsedDelta(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class AppCallbackPopCall__Outputs {
  _call: AppCallbackPopCall;

  constructor(call: AppCallbackPopCall) {
    this._call = call;
  }

  get newCtx(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}

export class CtxUseAllowanceCall extends ethereum.Call {
  get inputs(): CtxUseAllowanceCall__Inputs {
    return new CtxUseAllowanceCall__Inputs(this);
  }

  get outputs(): CtxUseAllowanceCall__Outputs {
    return new CtxUseAllowanceCall__Outputs(this);
  }
}

export class CtxUseAllowanceCall__Inputs {
  _call: CtxUseAllowanceCall;

  constructor(call: CtxUseAllowanceCall) {
    this._call = call;
  }

  get ctx(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get appAllowanceWantedMore(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get appAllowanceUsedDelta(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class CtxUseAllowanceCall__Outputs {
  _call: CtxUseAllowanceCall;

  constructor(call: CtxUseAllowanceCall) {
    this._call = call;
  }

  get newCtx(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}

export class JailAppCall extends ethereum.Call {
  get inputs(): JailAppCall__Inputs {
    return new JailAppCall__Inputs(this);
  }

  get outputs(): JailAppCall__Outputs {
    return new JailAppCall__Outputs(this);
  }
}

export class JailAppCall__Inputs {
  _call: JailAppCall;

  constructor(call: JailAppCall) {
    this._call = call;
  }

  get ctx(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get app(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get reason(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class JailAppCall__Outputs {
  _call: JailAppCall;

  constructor(call: JailAppCall) {
    this._call = call;
  }

  get newCtx(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}

export class CallAgreementCall extends ethereum.Call {
  get inputs(): CallAgreementCall__Inputs {
    return new CallAgreementCall__Inputs(this);
  }

  get outputs(): CallAgreementCall__Outputs {
    return new CallAgreementCall__Outputs(this);
  }
}

export class CallAgreementCall__Inputs {
  _call: CallAgreementCall;

  constructor(call: CallAgreementCall) {
    this._call = call;
  }

  get agreementClass(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get callData(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get userData(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }
}

export class CallAgreementCall__Outputs {
  _call: CallAgreementCall;

  constructor(call: CallAgreementCall) {
    this._call = call;
  }

  get returnedData(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}

export class CallAppActionCall extends ethereum.Call {
  get inputs(): CallAppActionCall__Inputs {
    return new CallAppActionCall__Inputs(this);
  }

  get outputs(): CallAppActionCall__Outputs {
    return new CallAppActionCall__Outputs(this);
  }
}

export class CallAppActionCall__Inputs {
  _call: CallAppActionCall;

  constructor(call: CallAppActionCall) {
    this._call = call;
  }

  get app(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get callData(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }
}

export class CallAppActionCall__Outputs {
  _call: CallAppActionCall;

  constructor(call: CallAppActionCall) {
    this._call = call;
  }

  get returnedData(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}

export class CallAgreementWithContextCall extends ethereum.Call {
  get inputs(): CallAgreementWithContextCall__Inputs {
    return new CallAgreementWithContextCall__Inputs(this);
  }

  get outputs(): CallAgreementWithContextCall__Outputs {
    return new CallAgreementWithContextCall__Outputs(this);
  }
}

export class CallAgreementWithContextCall__Inputs {
  _call: CallAgreementWithContextCall;

  constructor(call: CallAgreementWithContextCall) {
    this._call = call;
  }

  get agreementClass(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get callData(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get userData(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }

  get ctx(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }
}

export class CallAgreementWithContextCall__Outputs {
  _call: CallAgreementWithContextCall;

  constructor(call: CallAgreementWithContextCall) {
    this._call = call;
  }

  get newCtx(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }

  get returnedData(): Bytes {
    return this._call.outputValues[1].value.toBytes();
  }
}

export class CallAppActionWithContextCall extends ethereum.Call {
  get inputs(): CallAppActionWithContextCall__Inputs {
    return new CallAppActionWithContextCall__Inputs(this);
  }

  get outputs(): CallAppActionWithContextCall__Outputs {
    return new CallAppActionWithContextCall__Outputs(this);
  }
}

export class CallAppActionWithContextCall__Inputs {
  _call: CallAppActionWithContextCall;

  constructor(call: CallAppActionWithContextCall) {
    this._call = call;
  }

  get app(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get callData(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get ctx(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }
}

export class CallAppActionWithContextCall__Outputs {
  _call: CallAppActionWithContextCall;

  constructor(call: CallAppActionWithContextCall) {
    this._call = call;
  }

  get newCtx(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}

export class BatchCallCall extends ethereum.Call {
  get inputs(): BatchCallCall__Inputs {
    return new BatchCallCall__Inputs(this);
  }

  get outputs(): BatchCallCall__Outputs {
    return new BatchCallCall__Outputs(this);
  }
}

export class BatchCallCall__Inputs {
  _call: BatchCallCall;

  constructor(call: BatchCallCall) {
    this._call = call;
  }

  get operations(): Array<BatchCallCallOperationsStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      BatchCallCallOperationsStruct
    >();
  }
}

export class BatchCallCall__Outputs {
  _call: BatchCallCall;

  constructor(call: BatchCallCall) {
    this._call = call;
  }
}

export class BatchCallCallOperationsStruct extends ethereum.Tuple {
  get operationType(): BigInt {
    return this[0].toBigInt();
  }

  get target(): Address {
    return this[1].toAddress();
  }

  get data(): Bytes {
    return this[2].toBytes();
  }
}

export class ForwardBatchCallCall extends ethereum.Call {
  get inputs(): ForwardBatchCallCall__Inputs {
    return new ForwardBatchCallCall__Inputs(this);
  }

  get outputs(): ForwardBatchCallCall__Outputs {
    return new ForwardBatchCallCall__Outputs(this);
  }
}

export class ForwardBatchCallCall__Inputs {
  _call: ForwardBatchCallCall;

  constructor(call: ForwardBatchCallCall) {
    this._call = call;
  }

  get operations(): Array<ForwardBatchCallCallOperationsStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      ForwardBatchCallCallOperationsStruct
    >();
  }
}

export class ForwardBatchCallCall__Outputs {
  _call: ForwardBatchCallCall;

  constructor(call: ForwardBatchCallCall) {
    this._call = call;
  }
}

export class ForwardBatchCallCallOperationsStruct extends ethereum.Tuple {
  get operationType(): BigInt {
    return this[0].toBigInt();
  }

  get target(): Address {
    return this[1].toAddress();
  }

  get data(): Bytes {
    return this[2].toBytes();
  }
}
